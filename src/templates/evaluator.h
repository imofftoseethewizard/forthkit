/*{ title_block }*/

/*{ generation_details }*/

/*|

`CELL_TYPE` and `DOUBLE_TYPE` are intended to be compile-time
parameters.  They should both be signed integers, with double type
twice the size of cell type.  Eg, valid types for these are (`short`,
`long`), (`int`, `long long`), and (`long long`, `__int128`).  There
are of course many synonyms that would work, and the full range of
valid pairs depends on the architecture of the build system and
compilation target.  These are known to work on 64-bit Linux
(Ubuntu/Debian) with either a 32-bit -- for the first two pairs -- or
64-bit target.

  |*/

    typedef unsigned CELL_TYPE cell;
    typedef unsigned DOUBLE_TYPE double_cell;

    typedef CELL_TYPE number;
    typedef DOUBLE_TYPE double_number;

/*|

See templates/errors.md for more information about errors and error
codes.

  |*/

	enum error_codes {
		/*{ error_code_definitions }*/
	};

/*|

Given an error code, return the associated message.  This is useful
`evalautate` below returns a non-zero value.

  |*/

	extern const char *error_message(number code);

/*|

Given an error symbol, return the error code. This is useful to
understand the values the evaluator might return from an error code
that appears in Forth code.

  |*/

	extern int error_code(const char *symbol);

/*|



  |*/

/*{ declare_init_evaluator }*/

/*|


  |*/

    extern int evaluate_source(cell *evaluator, const char *source, int storage_fd);

/*|



  |*/

    extern cell *create_evaluator_image(cell *e0, cell *e1, int *image_size);

/*|



  |*/

    extern cell *load_evaluator_image(const char *image, int image_size);

/*|

The address model is either host or virtual.  (See the
templates/address_model directory.)  The host address model uses the
address space of the process running the evaluator.  The virtual
address model has a 0-based virtual address space.  There must be
agreement between the compilation target and the host address model in
that a pointer must fit into one cell.

The address model defines several macros which allow the translation
of cell references to host addresses, and from cell representations of
primitives to the value associated with the primitive's label
generated by the compiler.

`_to_ptr(x)` takes a cell-valued reference to another cell and returns
a pointer to the memory containing that cell.  No check is made that
the cell reference is actually within the evaluator's address space.

`_from_ptr(x)` takes a pointer to a memory address and returns the
cell value which refers to the cell that occupies that memory address.
No check is made that the pointer references memory within the
evaluator's address space.

In direct threaded evaluators, references to primitives may appear
throughout the definition of a word and we require a way to
distinguish them from defined words.  `_is_primitive(x)` accepts a
cell value and returns true if is refers to a primitive.  In indirect
threaded evaluators, references to primitives only appear in the cfa
of words, and the `_is_primitive` macro is not necessary and is
therefore not defined.

A _primitive value_ is the value the compiler assigns to the
primitive's label.  Depending on the execution model, it may be the
address of a subroutine, the address of a label for use with goto, or
an enumerated value used in a case statement.  The `_from_pv(x)` macro
accepts a primitive value and returns a cell value which represents
it.  `_to_pv(x)` provides the inverse functionality, accepting a cell
value and returning the primitive value it represents.  Note that no
check is made in either case for the validity of either the cell
representation nor that the primitive value is valid.

All of the macros above should only be expanded in the evaluator's
lexical context.  There are three symbols which appear in `host.h` and
`virtual.h` from that context. `e` is a `cell[]` value referring to
the address space of the evaluator. `_pr_value_base` and
`_pr_value_limit` are the numerical lower and upper limits of
primitive values.  In some configurations, none of these are
referenced -- indirect threaded host addressing, for example.
Nonetheless, it would be difficult to expand these successfully
outside of that context in a way that is unaware of the address or
execution model.

  |*/

/*{ address_model }*/

/*{ execution_model_decls }*/

    #define _from_pr(x) _from_pv(_pr_value(x))

/*|

`c_msb` is a cell value with a 1 in the most significant bit and
zeroes elsewhere.  It's used mostly in double number arithmetic.

  |*/

    #define c_msb ((cell)1 << (sizeof(cell) * 8 - 1))

/*|

These are some utility macros used to pack and unpack double numbers,
primarily used in the implementation of primitives.

`_from_high_word` accepts a `double number` and returns a `double
number` containing the upper half of the `double number` in its lower
half, the upper half being 0.

`_from_low_word` is similar, but the source is the low word.

The result of these two functions can be safely cast to a `number`.

The other two macros accept a `number` and return a `double number`,
performing the reverse operation to those above.

  |*/

	#define _from_high_word(x) ((x) >> (sizeof(number)*8))
	#define _from_low_word(x)  ((x) & (((double_number)1 << (sizeof(number)*8)) - 1))
	#define _to_high_word(x)   (((double_number)(x)) << (sizeof(number)*8))
	#define _to_low_word(x)    ((double_number)(x))

/*|

Built-in string handling for use with storing and retrieving the names
of words uses a length-prefixed format.  Given the limited intended
use, the length is just a single byte and refers the the length of
data stored, not the number of characters.

`_string_len` accepts the address of a string and returns its length.

`_string_addr` accepts the address of a string and returns the address
of the contents of the string.

  |*/

    #define _string_len(x)  *(unsigned char *)(x)
    #define _string_addr(x) (char *)((unsigned char *)(x) + 1)

/*|

TODO

  |*/

#define _compile_pr(x) _store_data(_from_pr(x))
#define _compile_cw(x) _store_data(_compiled_word_ref(x))

/*|

In an earlier version of Forthkit, there were numerous flags that
could be set on a word.  Over the evolution of the project all but
`c_immediate` and `c_inline` became disused and were removed.
`c_inline` is only relevant for direct threaded interpreters.  It is
set on primitive words during bootstrap and used by compilation words
to lift the single primitive in the word into the definition being
compiled, eliminating an enter operation.

  |*/

#define c_immediate   0b01
#define c_inline1     0b000000010
#define c_inline2     0b000000100
#define c_inline3     0b000000110
#define c_inline_mask 0b000000110

#define _set_word_flags(x, flags)       *((cell *)(x) + 2) |= (flags)
#define _clear_word_flags(x, flags)     *((cell *)(x) + 2) &= ~(flags)
#define _get_word_flags(x)              *((cell *)(x) + 2)
#define _get_inline_flag(flags)         (flags & c_inline_mask)
/*|

TODO

  |*/

#define _get_word_interpretation_ptr(x) ((cell *)(x) + 3)
#define _get_word_interpretation(x)     _from_ptr(_get_word_interpretation_ptr(x))

/*|

TODO

  |*/

#define _store_word_name()                                        \
do {                                                              \
    register cell name = _from_ptr(dp);                           \
    register cell *string_addr = _to_ptr(*sp);                    \
    register unsigned char n = *(unsigned char *)string_addr;         \
                                                                  \
    memcpy(dp, string_addr, n + 1);             \
    dp += n + 1;                                \
                                                                  \
    *sp = name;                                                   \
                                                                  \
} while (0)

/*|

TODO

  |*/

#define _word_header(flags)                                       \
       /* _word_header: ( n -- addr ) [xp]    */                  \
                                                                  \
       /* Align dp to a cell boundary.      */                    \
       dp = (char *)_align(dp);                                   \
                                                                  \
       /* Save address of new word.           */                  \
       *--rp = _from_ptr(dp);                                     \
                                                                  \
       /* Copy name address to word entry.    */                  \
       _store_data(*sp++);                                        \
                                                                  \
       /* Vocabulary list link.               */                  \
       _store_data(*_to_ptr(tp[ta_current]));                     \
                                                                  \
       /* Save word address for _end_define_word */               \
       *--sp = *rp++;                                             \
                                                                  \
       /* Word flags.                         */                  \
       _store_data(flags)

/*|

TODO

  |*/

#define _end_define_word()                                       \
	/* Add to current vocabulary.          */                    \
	*_to_ptr(_current()) = *sp++;

/*|

TODO

  |*/

#define _next_word(x) *(_to_ptr(x) + 1)

/*|

TODO

  |*/

#define _compiled_word_ref(e, l) e[e[ea_size] / sizeof(cell) - l - 1]
#define _register_compiled_word(l) _compiled_word_ref(e, l) = _from_ptr(dp)
#define _define_compiled_word(s, l, flags)                        \
        _begin_define_word(s, flags);                             \
        _register_compiled_word(l)

/*|

TODO

  |*/

#define _begin_define_word(s, flags)                              \
    do {                                                          \
        *--sp = _from_ptr(dp);                                    \
        dp = store_counted_string((s), dp);                       \
        _word_header(flags);                                      \
    } while(0)

/*|

TODO

  |*/

/*{ word_structure }*/

/*|

TODO

  |*/

#define _compile_parse_word()                                     \
        _compile_literal(32);                                     \
        _compile_literal(_from_ptr(&e[ea_word_buffer1]));         \
        _compile_pw(pr_fetch);                                    \
        _compile_pw(pr_word)

/*|

TODO

  |*/

#define _to_buffer_ptr(n) ((char *)_to_ptr(e[ea_buffers] + n * e[ea_buffer_size]))

/*|

.. c:macro: _enter

The

  |*/

/*{ define_enter }*/

#pragma GCC diagnostic ignored "-Wint-conversion"
#define _align(x) (cell *)((long)(x) + sizeof(cell) - 1 & ~(sizeof(cell) - 1))

#pragma GCC diagnostic ignored "-Wpointer-to-int-cast"
#define _store_data(x) *(cell *)dp = (cell)(x), dp += sizeof(cell)

#define _lshift() *++sp = *(sp+1) << *sp

/*|

Debugging support.

  |*/

#if VERBOSE

#define _info(...) fprintf(stderr, __VA_ARGS__)
#define _debug(...) fprintf(stderr, __VA_ARGS__)

#define _print_stack()                                                   \
do {                                                                     \
    register cell *spx = sp0;                                            \
                                                                         \
   _debug("stack: ");                                                    \
                                                                         \
    while (sp < spx)                                                     \
        _debug("%lx ", (long)*--spx);                                    \
                                                                         \
    _debug("\n");                                                        \
} while(0)

#define _print_return_stack()                                            \
do {                                                                     \
    register cell *rpx = rp0;                                            \
                                                                         \
    _debug("return stack: ");                                            \
                                                                         \
    while (rp < rpx)                                                     \
        _debug("%lx ", (long)*--rpx);                                    \
                                                                         \
    _debug("\n");                                                        \
} while(0)

#define _print_registers()                                               \
do {                                                                     \
    _debug("ip: %8lx; *ip: %8lx, *(ip+1): %8lx, rp: %8lx, *rp: %8lx, sp: %8lx, *sp: %8lx, dp: %8lx src: %.*s\n",  \
           _from_ptr(ip), ip?*ip:0, ip?*(ip+1):0,        \
           _from_ptr(rp), rp?*rp:0,                      \
           _from_ptr(sp), sp?*sp:0,                      \
           (long)_from_ptr(dp),                          \
           e[ea_source_len]-e[ea_source_idx], \
           (char *)_to_ptr(e[ea_source_addr]) + e[ea_source_idx]);      \
} while (0)

#else

#if LOG
#define _info(...) fprintf(stderr, __VA_ARGS__)
#else
#define _info(...)
#endif

#define _debug(...)
#define _print_stack()
#define _print_return_stack()
#define _print_registers()
#endif

#if TRACE

#define _trace(label)                                                    \
    do {                                                                 \
        _debug("%40s", label);                                          \
        _print_registers();                                             \
    } while(0)

#else

#define _trace(label)

#endif

#ifdef BOUNDS_CHECKING

#define _check_buffer_address(x)

#define _check_dictionary_bounds()                   \
do {                                                 \
    if (dp >= top)                                   \
        _abort(err_dictionary_overflow);             \
} while (0)

#define _check_loader_context_stack_bounds()

#define _check_minimum_stack_depth(n)                \
do {                                                 \
    if ((sp0 - sp) < (n))                            \
    _abort(err_parameter_stack_underflow);           \
} while (0)

#define _check_parameter_stack_bounds()              \
do {                                                 \
    if (sp > sp0)                                    \
        _abort(err_parameter_stack_underflow);       \
    else if (sp < sp0 - e[ea_parameter_stack_size])  \
        _abort(err_parameter_stack_overflow);        \
} while (0)

#define _check_return_stack_bounds()                 \
do {                                                 \
    if (rp > rp0)                                    \
        _abort(err_return_stack_underflow);          \
    else if (rp < rp0 - e[ea_return_stack_size])     \
        _abort(err_return_stack_overflow);           \
} while (0)

#define _is_valid_0_based_stack_index(n) ((n) >= 0 && sp + (n) < sp0)
#define _is_valid_1_based_stack_index(n) ((n) > 0 && sp + (n) <= sp0)

#else

#define _check_buffer_address()
#define _check_dictionary_bounds()
#define _check_loader_context_stack_bounds()
#define _check_minimum_stack_depth(n)
#define _check_parameter_stack_bounds()
#define _check_return_stack_bounds()

#define _is_valid_0_based_stack_index(n) 1
#define _is_valid_1_based_stack_index(n) 1

#endif

/*{ evaluator_decls }*/

/*{ additional_definitions }*/
char *store_counted_string(const char *s, char *dp);

/*|

This is the internal entrypoint to the evaluator.  It operates in two
distinct modes depending on which parameters are present and which are
NULL.

The primary mode of operation is to call `evaluate` with non-NULL
values or the first two parameters -- `evaluator` and `source` -- and
optionally a non-negative value for the third -- `storage_fd`.  The
first parameter must be an evaluator memory image that has been
previously initialized.  The second is the null-terminated string of
text that is to be evaluated.  The third parameter is a file
descriptor for block storage which if non-negative will allow the use
of the block word set.

A second mode is triggered by providing NULL, NULL, -1, and an out
parameter for a cell pointer.  It returns the number of primitives.
If the pointer is non-null, then the evaluator will allocate memory
and copy the cell representation of the primitive values the evaluator
was built with.  This memory block is statically defined and should
not be modified or freed.  This mode is used internally during image
loading to replace placeholder references with the actual values of
primitives in this process.  In the switch execution model, primitive
values will be the same from run to run, but in the computed goto and
local subroutine models they will be different.

  |*/
