#! /usr/bin/env python3

import argparse
import configparser
import re
import subprocess
import sys

from collections import namedtuple
from pathlib import Path
from pprint import *

Env = namedtuple('Env', ('name'))

Config = namedtuple('Config', ('name',
                               'address_model', 'concurrency', 'execution_model', 'thread_model',
                               'definitions', 'primitives', 'compiled_words', 'library_words'))

Params = namedtuple('Params', ('address_model', 'concurrency', 'execution_model', 'thread_model',
                               'definitions', 'primitives', 'compiled_words', 'library_words',
                               'base_name', 'target_dir'))

Primitive = namedtuple('Primitive', ('word_name', 'is_immediate', 'label', 'body'))

Primitives = namedtuple('Primitives', ('count', 'decls', 'impls', 'registry', 'word_defs'))

CompiledWord = namedtuple('CompiledWord', ('word_name', 'is_immediate', 'label', 'body'))

CompiledWords = namedtuple('CompiledWords', ('count', 'registry', 'word_defs'))

LibraryWords = namedtuple('LibraryWords', ('count', 'word_defs'))

ErrorData = namedtuple('ErrorData', ('id', 'symbol', 'desc'))

EmptyEnv = Env(None)
EmptyConfig = Config(None, None, None, None, None, None, None, None, None)

templates = Path(__file__).parent / '../codegen/templates'

address_models   = templates / 'address_models'
evaluator        = templates / 'evaluator'
execution_models = templates / 'execution_models'
threading        = templates / 'threading'

def main():

    env = get_env()

    parser = create_parser()
    args = parser.parse_args()

    config = read_config(args.config or env.config_path)

    # Look for cmd_* functions below to see what values args.command
    # can have.
    args.command(args, config, env)

def get_env():
    return EmptyEnv

def create_parser():
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    init_parser = subparsers.add_parser('init', help='initialize forthkit project')
    init_parser.set_defaults(command='init')

    gen_parser = subparsers.add_parser('gen', help='generate source files')
    gen_parser.set_defaults(command=cmd_generate)

    gen_parser.add_argument('-a', '--address-model', default='host',
                            choices=('h', 'v', 'host', 'virtual'))

    gen_parser.add_argument('-c', '--concurrency', default='single',
                            choices=('f', 's', 'fibered', 'single'))

    gen_parser.add_argument('-e', '--execution-model', default='switch',
                            choices=('g', 'l', 's', 'computed_goto', 'local_subroutine', 'switch'))

    gen_parser.add_argument('-t', '--thread-model', default='indirect',
                            choices=('d', 'i', 'direct', 'indirect'))

    gen_parser.add_argument('-C', '--config')
    gen_parser.add_argument('-N', '--base-name', default='evaluator')
    gen_parser.add_argument('-T', '--target-dir', default='./')
    gen_parser.add_argument('-d', '--definitions', nargs='*', default=[])
    gen_parser.add_argument('-p', '--primitives', nargs='*', default=[])
    gen_parser.add_argument('-w', '--compiled-words', nargs='*', default=[])
    gen_parser.add_argument('-l', '--library-words', nargs='*', default=[])

    build_parser = subparsers.add_parser('build', help='build source files')
    build_parser.set_defaults(command='build')

    run_parser = subparsers.add_parser('run', help='run an interpreter')
    run_parser.set_defaults(command='run')

    return parser

std_address_model = {
    'h':       'host',
    'host':    'host',
    'v':       'virtual',
    'virtual': 'virtual',
}

std_concurrency = {
    'f':       'fibered',
    'fibered': 'fibered',
    's':       'single',
    'single':  'single'
}

std_execution_model = {
    'g':                'computed_goto',
    'computed-goto':    'computed_goto',
    'computed_goto':    'computed_goto',
    'l':                'local_subroutine',
    'local-subroutine': 'local_subroutine',
    'local_subroutine': 'local_subroutine',
    's':                'switch',
    'switch':           'switch',
}

std_thread_model = {
    'd':        'direct',
    'direct':   'direct',
    'i':        'indirect',
    'indirect': 'indirect',
}

def read_config(config_path):

    if config_path is None:
        return EmptyConfig

    config = configparser.ConfigParser()
    config.read(config_path)

    if 'general' not in config:
        return EmptyConfig

    general = config['general']

    name            = general.get('name')
    address_model   = general.get('address_model')
    concurrency     = general.get('concurrency')
    execution_model = general.get('execution_model')
    thread_model    = general.get('thread_model')

    definitions     = parse_config_list_value(general.get('definitions', ''))
    primitives      = parse_config_list_value(general.get('primitives', ''))
    compiled_words  = parse_config_list_value(general.get('compiled_words', ''))
    library_words   = parse_config_list_value(general.get('library_words', ''))

    return Config(name,
                  address_model, concurrency, execution_model, thread_model,
                  definitions, primitives, compiled_words, library_words)

def parse_config_list_value(s):

    return [
        v for v in (
            part.strip() for part in s.split('\n')
        )
        if v
    ]

def cmd_generate(args, config, env):

    params = coalesce_generate_params(args, config, env)

    concurrency     = params.concurrency
    execution_model = params.execution_model
    address_model   = params.address_model
    thread_model    = params.thread_model

    additional_defs = '\n'.join(params.definitions)
    primitives      = process_primitives(params.primitives, execution_model, thread_model)
    compiled_words  = process_compiled_words(params.compiled_words)
    library_words   = process_library_words(params.library_words)

    evaluator_h_tmpl = read(templates / 'evaluator.h')
    evaluator_c_tmpl = read(templates / 'evaluator.c')

    error_data = load_error_data()
    error_code_defs_h = error_code_definitions(error_data)
    error_descs_c = error_descriptors(error_data)

    define_enter_h        = read(threading / thread_model / 'define_enter.c')
    word_structure_h      = read(threading / thread_model / 'word_structure.c')

    evaluator_decls_h     = read(evaluator / concurrency / 'evaluator_decls.c')

    address_model_h       = read((address_models / address_model).with_suffix('.c'))

    declare_init_evaluator_h = read(evaluator / concurrency / 'declare_init_evaluator.h')

    execution_model_decls = try_read(execution_models / execution_model / 'decls.c')

    h_values = {
        'additional_definitions': additional_defs,
        'address_model': address_model_h,
        'declare_init_evaluator': declare_init_evaluator_h,
        'define_enter': define_enter_h,
        'error_code_definitions': error_code_defs_h,
        'evaluator_decls': evaluator_decls_h,
        'execution_model_decls': execution_model_decls,
        'word_structure': word_structure_h,
    }

    thread_step_c         = read(threading / thread_model / 'execution_models' / execution_model / 'thread_step.c')

    begin_bootstrap_c     = read(evaluator / concurrency / 'begin_bootstrap.c')
    finish_bootstrap_c    = read(evaluator / concurrency / 'finish_bootstrap.c')
    evaluator_core_c      = read(evaluator / concurrency / 'execution_models' / execution_model / 'evaluator_core.c')
    init_evaluator_c      = read(evaluator / concurrency / 'init_evaluator.c')
    prepare_evaluation_c  = read(evaluator / concurrency / 'prepare_evaluation.c')

    declare_primitives_c  = try_read(execution_models / execution_model / 'declare_primitives.c')

    evaluator_variables_c  = (
        try_read(evaluator / concurrency / 'evaluator_variables.c') +
        try_read(execution_models / execution_model / 'evaluator_variables.c') +
        try_read(threading / thread_model / 'evaluator_variables.c')
    )

    c_values = {
        'begin_bootstrap': begin_bootstrap_c,
        'compiled_word_definitions': compiled_words.word_defs,
        'compiled_word_decls': '// TODO:compiled_word_decls',
        'declare_primitives': declare_primitives_c,
        'error_descriptors': error_descs_c,
        'evaluator_core': evaluator_core_c,
        'evaluator_variables': evaluator_variables_c,
        'finish_bootstrap': finish_bootstrap_c,
        'init_evaluator': init_evaluator_c,
        'initialize_primitive_registry': primitives.registry,
        'library_word_count': str(library_words.count),
        'library_word_definitions': library_words.word_defs,
        'prepare_evaluation': prepare_evaluation_c,
        'primitive_count': str(primitives.count),
        'primitive_decls': primitives.decls,
        'primitive_implementations': primitives.impls,
        'primitive_word_definitions': primitives.word_defs,
        'thread_step': thread_step_c,
    }

    evaluator_h = fill_template(evaluator_h_tmpl, h_values)
    evaluator_c = fill_template(evaluator_c_tmpl, c_values)

    base_path = Path(args.target_dir) / args.base_name

    h_path = base_path.with_suffix('.h')
    c_path = base_path.with_suffix('.c')

    print(reformat(evaluator_h), file=open(h_path, 'w'))
    print(reformat(evaluator_c), file=open(c_path, 'w'))

def coalesce_generate_params(args, config, env):

    raw_address_model   = args.address_model   or config.address_model
    raw_concurrency     = args.concurrency     or config.concurrency
    raw_execution_model = args.execution_model or config.execution_model
    raw_thread_model    = args.thread_model    or config.thread_model

    address_model   = std_address_model[raw_address_model]
    concurrency     = std_concurrency[raw_concurrency]
    execution_model = std_execution_model[raw_execution_model]
    thread_model    = std_thread_model[raw_thread_model]

    definitions    = config.definitions    + args.definitions
    primitives     = config.primitives     + args.primitives
    compiled_words = config.compiled_words + args.compiled_words
    library_words  = config.library_words  + args.library_words

    return Params(address_model, concurrency, execution_model, thread_model,
                  definitions, primitives, compiled_words, library_words,
                  args.base_name, args.target_dir)

def load_error_data():

    lines = read(templates / 'errors.md').split('\n')

    data_lines = [l for l in lines if l.startswith('    ')]

    return [ErrorData(*re.split(' +', l.strip(), 2)) for l in data_lines]

def error_code_definitions(error_data):

    return '\n'.join([f'{e.symbol} = {e.id},' for e in error_data])

def error_descriptors(error_data):

    return ',\n'.join([
        f'''{{{e.symbol}, "{e.symbol}", "{e.desc}"}}'''
        for e in error_data
    ])

def process_primitives(primitive_paths, execution_model, thread_model):

    primitives = [
        parse_primitive(path)
        for path in primitive_paths
    ]

    primitive_decl_tmpl = try_read(execution_models / execution_model / 'primitive_decl.c')

    if primitive_decl_tmpl:

        decls = '\n'.join([
            fill_template(primitive_decl_tmpl, {'label': p.label})
            for p in primitives
        ])

    else:
        decls = ''

    primitive_impl_tmpl = read(execution_models / execution_model / 'primitive_impl.c')

    impls = '\n'.join([
        fill_template(primitive_impl_tmpl, {'label': p.label, 'body': p.body})
        for p in primitives
    ])

    register_primitive_tmpl = read(templates / 'register_primitive.c')

    registry = '\n'.join([
        fill_template(register_primitive_tmpl, {'label': p.label})
        for p in primitives
    ])

    primitive_word_def_tmpl = read(threading / thread_model / 'primitive_word_def.c')

    word_defs = '\n'.join([
        fill_template(primitive_word_def_tmpl,
                      {
                          'label': p.label,
                          'word_name': f'"{p.word_name}"',
                          'flags': 'c_immediate' if p.is_immediate else '0',
                      })
        for p in primitives
        if p.word_name
    ])

    return Primitives(len(primitives), decls, impls, registry, word_defs)

primitive_re_text = r'\s*'.join([        # join all parts below with whitespace
    '',                                  # match whitespace at the beginning
    '(?://',                             # begin non-capturing group, discards //, whitespace, etc
    r'(?P<word_name>[^\s]+)',            # FORTH word name, whitespace delimited
    '(?P<immediate_flag>immediate)?',    # optional "immediate"
    ')?',                                # closes non-capturing group, entire line is optional
    '(?P<label>[_a-zA-Z][_a-zA-Z0-9]*)', # std C identifier
    ':',                                 # keeps primitive roughly C syntax compliant
    r'(?P<body>\{.*\})',                 # the actual implementation
    '$'                                  # ensure only whitespace after closing brace
])

# DOTALL allows body and whitespace matches to include newlines.
primitive_re = re.compile(primitive_re_text, re.DOTALL)

def parse_primitive(path):

    text = open(path).read()

    m = re.match(primitive_re, text)

    if not m:
        print(f'unable to parse primitive: {path}', file=sys.stderr)
        exit(1)

    return Primitive(m.group('word_name'),
                     m.group('immediate_flag') is not None,
                     m.group('label'),
                     m.group('body'))

def process_compiled_words(compiled_word_paths):

    compiled_words = [
        parse_compiled_word(path)
        for path in compiled_word_paths or []
    ]

    register_compiled_word_tmpl = read(templates / 'register_compiled_word.c')

    registry = '\n'.join([
        fill_template(register_compiled_word_tmpl, {'label': cw.label})
        for cw in compiled_words
    ])

    compiled_word_def_tmpl = read(templates / 'compiled_word_def.c')

    word_defs = '\n'.join([
        fill_template(compiled_word_def_tmpl,
                      {
                          'label': cw.label,
                          'word_name': f'"{cw.word_name}"',
                          'flags': 'c_immediate' if cw.is_immediate else '0',
                          'body': cw.body,
                      })
        for cw in compiled_words
        if cw.word_name
    ])

    return CompiledWords(len(compiled_words), registry, word_defs)

compiled_word_re_text = r'\s*'.join([    # join all parts below with whitespace
    '',                                  # match whitespace at the beginning
    '(?://',                             # begin non-capturing group, discards //, whitespace, etc
    r'(?P<word_name>[^\s]+)',            # FORTH word name, whitespace delimited
    '(?P<immediate_flag>immediate)?',    # optional "immediate"
    ')?',                                # closes non-capturing group, entire line is optional
    '(?P<label>[_a-zA-Z][_a-zA-Z0-9]*)', # std C identifier
    ':',                                 # keeps compiled_word roughly C syntax compliant
    r'(?P<body>\{.*\})',                 # the actual implementation
    '$'                                  # ensure only whitespace after closing brace
])

# DOTALL allows body and whitespace matches to include newlines.
compiled_word_re = re.compile(compiled_word_re_text, re.DOTALL)

def parse_compiled_word(path):

    text = open(path).read()

    m = re.match(compiled_word_re, text)

    if not m:
        print(f'unable to parse compiled_word: {path}', file=sys.stderr)
        exit(1)

    return CompiledWord(m.group('word_name'),
                        m.group('immediate_flag') is not None,
                        m.group('label'),
                        m.group('body'))

def process_library_words(library_word_paths):

    lines = [
        line.rstrip().replace('\\', '\\\\').replace('"', '\\"')
        for path in library_word_paths or []
        for line in open(path).readlines()
    ]

    return LibraryWords(len(lines), ',\n'.join([f'"{line}"' for line in lines]))

def read(path):
    return path.open().read()

def try_read(path):

    try:
        return read(path)
    except:
        return ''

def fill_template(tmpl, values):

    prior_result = ''
    result = tmpl

    while len(prior_result) != len(result):

        prior_result = result

        for k, v in values.items():

            pattern = '/*{ ' + k + ' }*/'
            result = result.replace(pattern, v)

    return result

def reformat(c_text):

    indent_cmd = 'indent --no-tabs -psl -kr -l128'.split()
    format_c_cmd = [
        str(Path(__file__).parent.parent / 'codegen' / 'format_c'),
        'C'
    ]

    p = subprocess.run(indent_cmd, input=c_text, text=True, capture_output=True)
    p.check_returncode()

    p = subprocess.run(format_c_cmd, input=p.stdout, text=True, capture_output=True)
    p.check_returncode()

    return p.stdout



if __name__ == '__main__':
    main()
