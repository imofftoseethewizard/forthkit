The evaluator is initialized with `here` at the least available memory location,
as a way to communicate the base of legal addresses to the primitive
interpreter. It is important to note that there are important system values at
and above that location that should not be changed. The primitive interpreter
needs to save that value and `allot` enough space to ensure that the definitions
below do not overwrite this region. At the outset, the only location we have to
store data is the parameter stack, so we'll save the initial value of the
dictionary pointer as the lowest stack item.

    [ here system-reserved allot ]

    [ define system ]
        <literal> [ swap , ]
        exit

So that we can just

Next, we will also need a compact way to create new words.

    [ define entry ]
        align here
        rot ,
        rot ,
        swap ,
        exit

    [ define variable ]
        <literal> [ ' <literal> , ] ,
        here <literal> 2 cells +    ,
        <literal> [ ' exit , ]      ,
        exit

At first glance, that is probably incomprehensible, so let's unpack it a couple
words at a time. First of all `entry` requires that the first 3 stack values
are: the word's flags -- immediate, e.g. -- the address of a counted string
holding the name of the new word, and finally the address of the most recently
defined word. The objective is to create the header of a word definition in the
dictionary. This consists of the name token -- that counted string address --
the address of the previous word, the word's flags, and thereafter the code
which the word will perform when executed. To begin, `align here` puts the
dictionary pointer on a cell boundary and puts its value on the top of the
stack. At this point, the address of the name is the third value on the stack,
so `rot ,` takes care of the first cell of the new word. The link address was
fourth, but is now third, so another `rot ,` will take care of that. We're left
with the word's address and the flags, so `swap ,` puts the flags in the flags
where they belong. We're left with the address of this word, which the next word
will need on the top of the stack, and we have the dictionary pointer ready to
compile code for this word.

    [ define constant-flag                   ] <literal> 0x0001 exit
    [ define immediate-flag                  ] <literal> 0x0002 exit
    [ define inline-flag                     ] <literal> 0x0004 exit
    [ define primitive-flag                  ] <literal> 0x0008 exit
    [ define restrict-flag                   ] <literal> 0x0010 exit
    [ define operand_ip_absolute-flag        ] <literal> 0x0020 exit
    [ define operand_ip_offset-flag          ] <literal> 0x0040 exit
    [ define operand_indirect_ip_offset-flag ] <literal> 0x0080 exit
    [ define operand_literal-flag            ] <literal> 0x0100 exit

The `entry` macro presumes that the link to the previous word in the dictionary is
on the top of the stack. Words are stored as a linked list terminated by 0, so we
need to put a 0 on the stack to start defining words.

    [ 0 ]

With that, we can create the dictionary entry for `STATE`:

    [ name: STATE constant-flag entry ]
    [ define state ]
        <literal> [ here 2 cells + , ]
        exit
        0

`name:` is a primitive which reads the next space delimited word from the input
stream, compiles it into the dictionary as a counted string, and leaves the
address of that string on the stack. `entry` was described immediately
above. The final `constant-flag ,` stores the flags associated with this word, in
this case, a flag indicating that the word's execution semantics is just to put
a literal on the stack. The dictionary pointer is also currently the xt of this
word -- a thing which will surely come in handy later -- and so we finish with
`here swap`. Leaving the stack with the address of the new word on the top, and
its xt just below.

Now that the word's dicionary entry has been stored, the `here` returns the
address of the execution token for `STATE`, which we will save on the stack.  At
this point, the stack contains the link address to `STATE` at the top, the xt of
`STATE`, and the value that state should return at the bottom.

This line switches to compilation state, compiles the operand for a literal,
then switches back interpretation state, rotates the stack to bring the address
of the state variable to the top and then compiles it as the operand of the
literal. After one more switch back to compiling to finish the word with `exit`,
we have our first word in the dictionary.

At this point, there are two values on the stack. On the top is the address of
the word for `STATE` and below that, its xt. Throughout the definition of
dictionary, we will keep the stack in a similar arrangement, accumulating xts
below the address of the most recently defined word. In this way, we can
relilably reference the xt for `STATE` using `SP0 1 cells - @`. This would be
cumbersome and error prone to track manually, so it's worth a little m4 magic:


So that we can just

Recall that the ultimate goal here is to bring up enough of the dictionary so
that we can define the interpreter, and from there -- in a more convenient and
forgiving language -- define the rest of the system. What will be implemented
here in f0, versus as a primitive in C is a matter of taste. For this
interpreter, the general idea is to implement words related to parsing and
compilation in f0, and in C the words that would benefit from either the speed
of a C implementation, or that would simply be impossible otherwise. For this
interpreter we'll need `PARSE`, `FIND`, and `>NUMBER` before we can implement
the interpreter. Those words will of course also need some component words.

Let's start with `PARSE`. We'll need to define `BEGIN`, `WHILE`, `REPEAT`, `IF`, and
`THEN`. The remainder are primitives.

`BEGIN` leaves a destination -- aka `dest` -- on the stack. That's just `here`,
the address of the next cell to be compiled.

    [ name: BEGIN immediate-flag entry ]

    [ define begin ]
        here
        exit

`WHILE` compiles a primitive which branches when the top of the stack is 0. The
destination of the branch is as yet undetermined, so we'll leave a placeholder
of 0.  and pushes the address of the `<0branch>`s operand to the stack. This is
known as an origin or `orig`. Additionally, it keeps the `dest` from the `BEGIN`
on the top, requiring a `swap`.

    [ name: WHILE immediate-flag entry ]

    [ define while ]
        <literal> <0branch> ,
        here <literal> 0 ,
        swap
        exit

`REPEAT` completes the begin/while construction, consuming both the
`dest` and the `orig`. It compiles a `<jump>` back to the `BEGIN` using the
`dest`, and then finalizes the `orig` by storing the offset from the operand to
the address of the next cell.

    [ name: REPEAT immediate-flag entry ]

    [ define repeat ]
        <literal> <jump> ,
        here - ,
        here over - swap !
        exit

Similar to `WHILE`, `IF` tests if the top of the stack is 0, and branches if it
is, and so it also pushes an origin -- aka `orig` -- onto the stack.

    [ name: IF immediate-flag entry ]

    [ define if ]
        <literal> <0branch> ,
        here <literal> 0 ,
        exit

    [ name: ELSE immediate-flag entry ]

    [ define else ]
        <literal> <jump> ,
        here <literal> 0 ,
        swap here over - swap !
        exit

    [ name: THEN immediate-flag entry ]

    [ define then ]
        here over - swap ! exit

    [ name: DO immediate-flag entry ]

    [ define do ]
        <literal> <do> ,
        <literal> 0 ,
        here
        exit

    [ name: LOOP immediate-flag entry ]

    [ define loop ]
        <literal> <loop> ,
        dup here - ,
        cell - here swap !
        exit

    [ name: AHEAD immediate-flag entry ]

    [ define ahead ]
        <literal> <jump> ,
        here <literal> 0 ,
        exit

Since each of these is compile-only, we can safely and without much confusion
use m4 to make the remainder a little easier to write

We need three more things before we can define `PARSE`; `TIB`, `>IN`, and
`#TIB`.

    [ name: TIB constant-flag entry ]

    [ define tib ]
        <literal> [ system source_addr + , ]
        exit

Similarly for the other two:

    [ name: >IN constant-flag entry ]

    [ define >in ]
        <literal> [ system source_idx + , ]
        exit

    [ name: #TIB constant-flag entry ]

    [ define #tib ]
        <literal> [ system source_len + , ]
        exit

WORD
SEARCH-WORDLIST
CURRENT
FIND

    [ name: /STRING 0 entry ]

    [ define /string ]
        swap over 2>r +
        2r> -
        exit

    [ name: bl? 0 entry ]

    [ define bl? ]
        <literal> 33 u<
        exit

    [ name: name-char? 0 entry ]

    [ define name-char? ]
        <literal> 32 u>
        exit

    [ name: skip-matching 0 entry ]

    [ define skip-matching ]
        >r
        [ begin ]
            dup
        [ while ]
                over c@ r@ execute
                [ while ]
                        <literal> 1 /string
                [ repeat ]
        [ then ]
        r> drop
        exit

With that we can define `PARSE`:

    [ name: PARSE-NAME 0 entry ]

    [ define parse-name ]

        tib @ #tib @ >in @ /string

        <literal> [ ' bl? ,        ] skip-matching over >r
        <literal> [ ' name-char? , ] skip-matching

        2dup <literal> 1 min + tib @ - >in !
        drop r> swap over -

        exit

    [ name: PARSE 0 entry ]

    [ define parse ]

        tib @ #tib @ >in @ /string over >r

        [ ahead here swap ]
            <literal> 3 pick =
            exit

        [ then <literal> , ]

        skip-matching

        2dup <literal> 1 min + tib @ - >in !
        drop r> swap over -

        exit

Finally, we'll need this, since we will refer to it again later:

Let's define `WORD`.

    [ define word-buffer variable 0x40 allot ]

    [ name: WORD 0 entry ]

    [ define word ]

        >r

        tib @
        #tib @
        over + swap
        >in @ +

        [ begin ]
             2dup >
        [ while ]
                dup c@ r@ =
            [ while ]
                    1+
            [ repeat ]
        [ then ]

        nip

        tib @ - >in !

        r>

        parse-name

        ?dup
        [ if ]
            dup <literal> [ word-buffer , ] c!

            <literal> [ word-buffer 1+ , ] swap cmove

            <literal> [ word-buffer , ]
        [ else ]
            drop
            <literal> 0
        [ then ]

        exit

Next we'll need a definition of find.

    [ name: SEARCH-WORDLIST 0 entry ]

    [ define search-wordlist ]

        @ >r
        [ begin ]
            r@
        [ while ]
            2dup r@ @ count
            compare 0=
            [ if ]
                2drop r@ <literal> 3 cells +
                r> <literal> 2 cells + @ <literal> immediate-flag and
                [ if ] <literal> 1 [ else ] <literal> -1 [ then ]
                exit
            [ then ]
            r> cell + @ >r
        [ repeat ]

        2drop r>
        exit

    [ name: `#VOCS' constant-flag entry ]

    [ define #vocs ]

        <literal> 16 exit

    [ name: `#ORDER' constant-flag entry ]
    [ define #order variable 0 , ]

    [ name: CONTEXT constant-flag entry ]
    [ define context variable 0x10 cells allot ]

    [ name: FORTH-WORDLIST constant-flag entry ]
    [ define forth-wordlist variable 0 , ]

    [ name: SET-ORDER 0 entry ]

    [ define set-order ]

       dup <literal> -1 =
       [ if ]
           drop
           forth-wordlist <literal> 1
       [ then ]
       dup #order !
       <literal> 0
       [ do ]
           i cells context + !
       [ loop ]
       exit

    [ name: GET-CURRENT 0 entry ]

    [ define get-current ]
        <literal> [ here 3 cells + , ] @
        exit
        [ forth-wordlist , ]

    [ name: compile-name 0 entry ]

    [ define compile-name ]
        parse-name
        ?dup
        [ if ]
            align here dup >r
            swap dup allot
            cmove
            r>
        [ else ]
            <literal> err_attempt_to_use_zero_length_string_as_a_name <abort>
        [ then ]
        exit

    [ name: : 0 entry ]
        compile-name align ,
        get-current @ ,
        <literal> 0 ,
        <literal> 1 state !
        exit

    [ name: ; immediate-flag entry ]
        get-current !
        <literal> 0 state !
        align
        exit

    [ name: find-word 0 entry ]

    [ define find-word ]

        #order @ <literal> 0
        [ do ]
            2dup
            i cells context + @
            search-wordlist
            ?dup
            [ if ]
                2swap 2drop
                unloop
                exit
            [ then ]
        [ loop ]
        <literal> 0
        exit

    [ name: BASE constant-flag entry ]
    [ define base variable 10 , ]

    [ name: CHAR 0 entry ]

    [ define char ]

        parse-name

        ?dup
        [ if ]
            drop c@

        [ else ]
            2drop
            <literal> 0

        [ then ]
        exit

    [ name: >digit 0 entry ]

    [ define >digit ]

        <literal> [ char 0 , ] -
        dup <literal> 10 u<
        [ if ]
            exit
        [ then ]

        <literal> [ char A char 0 - , ] -
        dup <literal> 26 u<
        [ if ]
            <literal> 10 +
            exit
        [ then ]

        <literal> [ char a char A - , ] -
        dup <literal> 26 u<
        [ if ]
            <literal> 10 +
            exit
        [ then ]

        drop
        <literal> -1

        exit

    [ name: >NUMBER 0 entry ]

    [ define >number ]

        [ begin ]
            dup

        [ while ]
            swap
            dup c@ >digit

            dup base @ u<
            [ while ]
                >r
                2swap
                base @ <literal> 1 m*/
                r> <literal> 0 d+
                2swap >r >r 2dup r> r>

                1+
                swap 1-
            [ repeat ]

        [ else ]
            drop
            swap

        [ then ]

        exit

    [ name: INTERPRET 0 entry ]

        <literal> 42 emit
        [ begin ]
            parse-name
            ?dup
        [ while ]
                find-word dup
                [ if ]
                    0>
                    state @ 0= or
                    [ if ]
                        execute
                    [ else ]
                        compile,
                    [ then ]
                [ else ]
                    <literal> 0 rot count >number
                    0=
                    [ if ]
                        drop swap drop
                        state @
                        [ if ]
                            <literal> <literal> , ,
                        [ then ]
                    [ else ]
                        <literal> err_undefined_word <abort>
                    [ then ]
                [ then ]
        [ repeat ]

        exit


    [ define primitive ]
        name: <literal> [ primitive-flag inline-flag or , ] entry
        ,
        <literal> [ ' exit , ] ,
        exit

    [ ' ! primitive ! ]

__define_primitive(!)
__define_primitive(`*')
__define_primitive(`*/')
__define_primitive(`*/MOD')
__define_primitive(`+')
__define_primitive(`+!')
__define_primitive(`,')
__define_primitive(`-')
__define_primitive(`/')
__define_primitive(`/MOD')
__define_primitive(`0<')
__define_primitive(`0=')
__define_primitive(`1+')
__define_primitive(`1-')
__define_primitive(`2!')
__define_primitive(`2*')
__define_primitive(`2/')
__define_primitive(`2@')
__define_primitive(`2drop')
__define_primitive(`2swap')
__define_primitive(`2dup')
__define_primitive(`2over')
__define_primitive(`2swap')
__define_primitive(`<')
__define_primitive(`=')
__define_primitive(`>')
__define_primitive(`>r')
__define_primitive(`?dup')
__define_primitive(`@')
__define_primitive(`ABS')
__define_primitive(`allot')
__define_primitive(`and')
__define_primitive(`c!')
__define_primitive(`C,')
__define_primitive(`c@')
__define_primitive(`cells')
__define_primitive(`drop')
__define_primitive(`dup')
__define_primitive(`EMIT')
__define_primitive(`execute')
__define_primitive(`exit')
__define_primitive(`FILL')
__define_primitive(`here')
__define_primitive(`I')
__define_primitive(`INVERT')
__define_primitive(`J')
__define_primitive(`KEY')
__define_primitive(`LSHIFT')
__define_primitive(`M*')
__define_primitive(`MAX')
__define_primitive(`min')
__define_primitive(`MOD')
__define_primitive(`MOVE')
__define_primitive(`NEGATE')
__define_primitive(`or')
__define_primitive(`over')
__define_primitive(`QUIT')
__define_primitive(`r>')
__define_primitive(`r@')
__define_primitive(`rot')
__define_primitive(`RSHIFT')
__define_primitive(`swap')
__define_primitive(`U<')
__define_primitive(`UM*')
__define_primitive(`UM/MOD')
__define_primitive(`XOR')
__define_primitive(`0>')
__define_primitive(`2>r')
__define_primitive(`2r>')
__define_primitive(`2r@')
__define_primitive(`<>')
__define_primitive(`COMPILE,')
__define_primitive(`nip')
__define_primitive(`PICK')
__define_primitive(`ROLL')
__define_primitive(`U>')

[ forth_wordlist !
  -1 SET_ORDER
  INTERPRET interpret !
    [ hello ]
