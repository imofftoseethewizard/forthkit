naming convention for executables
  <f79|f83|f94|f-ansi|f12|f-std>-<cell bits>-<length bits>-<thr(eaded)|sw(itched)|sub(routine)>-<r(elocatable)|a(bsolute)>
  eg
    f79-32-16-thr-r:
      * FORTH-79
      * 32 bit cells
      * 16 bit lengths (for counted strings)
      * threaded execution
      * relocatable image


tools
  rationale: ubiquitious and lightweight
  a c compiler: bcc, clang, gcc, icc, pcc, tcc
  m4
  make
  sh

action
  inputs: config, primitives, template
  outputs: .h and .c files
    <describe content of those files>

m4
  diversions
    1: declarations
    2: implementations


1. enumerate types of references to primitives
  3 aspects:
    1. syntatic form
      named "pr_%"
      translate syntactic form to register repr ... rename _pr_value?
    1. register representation (fn ptr, label, or enum for switch)
      execute
      translate to compiled rep ... _from_pv(x)
      translate to syntatic form(?) ... TODO _pv_name(x)
    2. compiled representation (can be stored in memory)
      translate to register rep ... _to_pv(x)
      store in memory
      read from memory
      test memory: primitive or compiled word?
    3. native code

  * pre-requisites ("#define"s)
  * declare
      direct -- n/a
      subroutine -- auto
      switch -- token enum
  * implement
      include primitive body
  * compile
      include reference in compiled word
  * deref _load_pr
      read compiled primitve into register
  * execute
      dispatch primitive from register


problem:
  input
    m4 preamble
    template (m4->c)
    operators and primitives
    compiled words

  define specification for
    add to lexical context
      include
      globals
      locals
    primitive
      dependencies
      code block
      lexical context
        e dp ip rp sp
    address model
    execution method
    word layout (including direct vs indirect)

m4 compiled words?
  TODO _register_operator, _define_primitive, etc.
  _register_operator
    used for debugging/tracing to translate compiled operators to text

  primitive(x) -> #define _x() _compile_pr(x)
  _compile_literal(x) -> _literal(x)
  _compile_pr(x) -> _x() if x != l


restructure primitives for m4
  _primitive(...) -> primitive(...)
  concat macros/p/x.h with primitives/q/x.h to primitives/p/x.m4

1. discover which optimizations cause failures in absolute addressing
   individually and pairwise for individual optimizations,
   no segfaults/bus errors, but -O1 still fails
6. switch based dispatch
2. separate primitive impl from dictionary init
4. interpreter structure test harness
    f0
    itemize functional pieces by execution model
      primitive declaration
        threaded: none
        subroutine: local function declaration
        switch: none
      primitive implementations
        threading: labeled block
        subroutine: local function
        switch: case block
      primitive definition in dictionary
      compiled word definition
      _next
      dispatch loop
        threaded: none
        subroutine: after local fn decls
        switch: around prim impl

    single cli command to
      compile all allowable address/threading combinations
      exercise all state transitions

    dimensions
      word size: 16, 32, 64
      compilation target: 32, 64
      address mode: absolute, relative
      reference model: direct, indirect
      dispatch model: switched, subroutine, threaded
    allowable region:
      absolute address => word size = compilation target
      word size <= compilation target
    combinations
      absolute addressing: 12 (compilation target * reference model * dispatch model)
      relative addressing:
        word size 16: 12 (compilation target * reference model * dispatch model)
        word size 32: 12 (compilation target * reference model * dispatch model)
        word size 64: 6 (reference model * dispatch model)
      total: 42

    operators
      abort
      branch
      do
      does
      exit
      jump
      literal
      loop
      n-loop
      (execute)

    _is_primitive -- true if cell represents a primitive
    _pr_deref     -- cell to (void *), referring to the implementation of a primitive
    _from_ptr     -- translates a (cell *) to a cell, inverse of _to_ptr
    _to_ptr       -- translates a cell which references another to (cell *), inverse of _from_ptr

5. indirect threading
7. load/save relocatable images
8. multi-threading
9. local multi-process
10. indirect primitives for 2 byte word size, or translate more primitives to compiled
11. token-based dispatch (ie, op_X and pr_X are mapped to/from enum)
    might be necessary if compiled code for relocatable 16-bit forth > 32kb.
14. other compilers: clang, bcc, tcc, pcc, icc
14.
    consistency checks (config option)
    test suite
      double number words

    selected (all?) items from reference word set
    reorg test suite

11. f83
12. f94
13. f2012
12. investigate Joy and HVM.