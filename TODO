upper memory allotment
  ea_top -- highest addressable cell
  reserve (n -- addr) e[ea_top] -= n, return e[ea_top]
  top ( -- n) return e[ea_top]



move memory layout config to runtime parameters (init_evaluator)
    #define FIBER_STACK_SIZE         4    /* move to runtime */
    #define FIBER_COUNT              4    /* move to runtime */
    #define MAX_WORD_LENGTH          64   /* move to runtime */
    #define PARAMETER_STACK_SIZE     128  /* move to runtime */
    #define RETURN_STACK_SIZE        256  /* move to runtime */
    #define SOURCE_SIZE              1024 /* move to runtime */
    #define TASK_COUNT               2    /* move to runtime */
    primitive/core/hold.m4:#define _number_pad_buf_addr() ((char *)e + e[ea_size] - e[ea_buffer_count] * e[ea_buffer_size] - _c_number_pad_size)

    ex. BUFFER_COUNT
      add ea_buffer_count
      sed -i 's/BUFFER_COUNT/e[ea_buffer_count]/'
      add cell buffer_count parameter to init_evaluator and initialize e[ea_buffer_count] = buffer_count
      change init_evaluator call sites to have new parameter
      add cli option for --buffer-count/-b in interpreter and test-runner
      add DEFAULT_BUFFER_COUNT to ?
      also MIN_BUFFER_SIZE, MAX_BUFFER_SIZE

    list of options              allowed range
      -b/--buffer-count          0-N
      -B/--buffer-size           1-N
      -F/--fiber-stack-size      1-N
      -f/--fiber-count           1-N
      -w/--max-word-length       16-N
      -P/--parameter-stack-size  16-N
      -R/--return-stack-size     16-N
      -S/--source-size           16-N
      -t/--task-count            1-N

     return result as process exit code for testing
     read and evaluate additional arguments as files
     other options

       -i/--interactive
       -q/--quiet
       -c/--command <text>
       -E/--evaluator-size





inputs to make
  common
    PREAMBLE
    EXECUTION_MODEL
    EVALUATOR_PRIMITIVES
  variable
    MEMORY_MODEL
    COMPILED_WORDS
    CONFIG_H
    EVALUATOR
    TEST_RUNNER

  source $config && make all

test system
  watch files
  on change
    record commit hash, git diff
    for each config spec (in some list in a file)
      make
      if make successful
        run make, tests, record any failing tests
  parameterize make for target name
  create list of configs

  parameterized make
    CFLAGS = -D config or -D <config>=<value>

test harness
  separate evaluate.c into evaluate.c and interepreter.c
  create test.c parallel to interperter.c
    accepts test file name from cmd line, returns 0 if tests pass
    handles verifying non-zero result codes

    f79-test [-r symbol/number] test-file

core fiber test suite
  braid
  end
  fiber
  lay
  snip
  start
  twist

move loader context stack out of return stack
move fibers and tasks up to buffer memory

slab tooling for buffers, fibers, and tasks.

fiber migration
  objective
    support debugger
    support step-based round-robin multi-fiber threads
    support "async" model ala js, Python

  1. execute a word in a separate fiber, same task
    a. allocate and initialize a fiber
      : ?? ( xt -- f )
        fiber dup >r
        0 r@ >f-rp
        r@ f-ip !
        r>
      ;
    b. push onto fiber stack
      xt fiber start
    c. demonstrate that it ran on a separate return stack
    d. end/clean up

  2. step through a word in a separate fiber
    a. set f-steps to 1 for each step
    b. display ip each step.

  3. execute a word in a separate fiber, new task
    a. allocate and initialize task
    b. proceed as in item 1.

  order
    indirection for task
    interpreter task
    fiber/task primitives/words/tests

  change *fp, *tp values to be indicies, rather than ptrs

  indirection for task attributes
  identify/define task/fiber words
    fiber ( xt -- f ) gets next empty fiber
      initialize ip = xt, rp, rp0 in fiber
    snip ( -- ) f1 f0 -> f0 (clear f1)
    twist ( -- ) f1 f0 -> f0 f1
    braid ( n -- ) ; fn ... f1 f0 --> f1 ... fn f0
    end ( -- ) ; f1 f0 -> f1 (clear f0)
    start (f -- ) ; f0 -> f0 f
    #f ( -- n )
    f@ ( n -- f )
    f-ip ( f -- addr )
    f-rp ( f -- addr )
    >f-rp
    f-rp>
    f-rp0 ( f -- addr )
    f-rp-stop ( f -- addr )
    f-steps ( f -- addr )
    t-dp
    t-sp
    t-sp0
    >t-sp
    t-sp>


types of concurrency
  - f0: ip/rp/rp_stop/step -- useful for debugging, profiling
  - f1: ip/rp/rp_stop/sp/step -- some types of concurrency -- coop or step-based -- limited
      dict changes
  - f2: full state, same address space -- full dict changes, sync primitives,
      e[...] will need abstraction
  - t0: full state, same address space with processor threads -- stdlib thread prims,
      full dict changes, sync primitives
      e[...] will need abstraction
  - t1: separate address space in same process, processor threads -- stdlib thread, sync prims,
  - m0: separate process, local -- POSIX mp primitives
  - m1: separate process, remote -- POSIX mp primitives, network

fiber
    ip
    rp
    rp0
    rp_stop
    steps
    taskp

task
  each task has a primary fiber
    bp
    dp
    sp
    sp0

  ip/rp/rp0/steps/rp_stop
  fiber (xt -- ) creates fiber, pushes to top of fiber stack
  twist ( -- )
    store ip/rp/rp0 in fiber on top of fiber stack,
    swap top of fiber stack,
    load ip/rp/rp0 from fiber on top of fiber stack

  braid ( n -- ) n > 0
    1 braid is a no-op
    2 braid swaps the second and third items in the fiber stack
    3 braid moves the 4th item to the 2nd position, and moves the 2nd and 3rd each
      down one spot
  join
    drop top of fiber stack
    load ip/rp/rp0 from fiber on top of fiber stack

debugging use of fiber

  debug evaluator changes
    implement step, next, out
    on break, set run, debug-fiber twist

  xt debug -- sets up a fiber
  ss --  <set single step> _twist

thread
  context
    fp/fp0
    ip
    rp/rp0/rp_stop
    sp/sp0
    steps


  current context
    on switch/push/pop copy regs into current context

  switch ( ctx -- ) switch context, set regs into current, set current to ctx, read regs


debugging
  requires debug build
    before prim check
      check for breakpoint
      check for steps == 0 (ss/ms)
      check for ip == <> (nx)
      check for rp == <> (so)
    check


  <xt> debug.. sets up a debug context
  stack of stacks (say 4 stacks of 64 cells each) impl dependent parameters

  : debug' 32 word find ?dup if debug else ... then ;
  \s (single step)
  \o (step out)
  \w (next word)
  n \m (multistep)
  \r (run)
  \b (break)
  \bt backtrace
  bp

  debug context:
    ip
    rp
    <space for rp>
    break points

  breakpoint

naming convention for executables
  <f79|f83|f94|f-ansi|f12|f-std>-<cell bits>-<length bits>-<thr(eaded)|sw(itched)|sub(routine)>-<r(elocatable)|a(bsolute)>
  eg
    f79-32-16-thr-r:
      * FORTH-79
      * 32 bit cells
      * 16 bit lengths (for counted strings)
      * threaded execution
      * relocatable image


tools
  rationale: ubiquitious and lightweight
  a c compiler: bcc, clang, gcc, icc, pcc, tcc
  m4
  make
  sh

1. discover which optimizations cause failures in absolute addressing
   individually and pairwise for individual optimizations,
   no segfaults/bus errors, but -O1 still fails
4. interpreter structure test harness
    f0
    itemize functional pieces by execution model
      primitive declaration
        threaded: none
        subroutine: local function declaration
        switch: none
      primitive implementations
        threading: labeled block
        subroutine: local function
        switch: case block
      primitive definition in dictionary
      compiled word definition
      _next
      dispatch loop
        threaded: none
        subroutine: after local fn decls
        switch: around prim impl

    single cli command to
      compile all allowable address/threading combinations
      exercise all state transitions

    dimensions
      word size: 16, 32, 64
      compilation target: 32, 64
      address mode: absolute, relative
      reference model: direct, indirect
      dispatch model: switched, subroutine, threaded
    allowable region:
      absolute address => word size = compilation target
      word size <= compilation target
    combinations
      absolute addressing: 12 (compilation target * reference model * dispatch model)
      relative addressing:
        word size 16: 12 (compilation target * reference model * dispatch model)
        word size 32: 12 (compilation target * reference model * dispatch model)
        word size 64: 6 (reference model * dispatch model)
      total: 42

    operators
      abort
      branch
      do
      does
      exit
      jump
      literal
      loop
      n-loop
      (execute)

    _is_primitive -- true if cell represents a primitive
    _pr_deref     -- cell to (void *), referring to the implementation of a primitive
    _from_ptr     -- translates a (cell *) to a cell, inverse of _to_ptr
    _to_ptr       -- translates a cell which references another to (cell *), inverse of _from_ptr

5. indirect threading
7. load/save relocatable images
8. multi-threading
9. local multi-process
10. indirect primitives for 2 byte word size, or translate more primitives to compiled
14. other compilers: clang, bcc, tcc, pcc, icc
14.
    consistency checks (config option)
    test suite
      double number words

    selected (all?) items from reference word set
    reorg test suite

11. f83
12. f94
13. f2012
12. investigate Joy and HVM.
15. posix signal handling